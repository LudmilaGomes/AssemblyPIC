;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*              MODIFICAÇÕES PARA USO COM 12F675                   *
;*                FEITAS PELO PROF. MARDSON                        *
;*                     JULHOO DE 2024                              *
;*                 BASEADO NO EXEMPLO DO LIVRO                     *
;*           Desbravando o PIC. David José de Souza                *
;*-----------------------------------------------------------------*
;*   MODELO PARA O PIC 12F675                                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ARQUIVOS DE DEFINIÇÕES                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
#INCLUDE <p12f675.inc>	;ARQUIVO PADRÃO MICROCHIP PARA 12F675

	__CONFIG _BODEN_OFF & _CP_OFF & _PWRTE_ON & _WDT_OFF & _MCLRE_ON & _INTRC_OSC_NOCLKOUT

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    PAGINAÇÃO DE MEMÓRIA                         *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;DEFINIÇÃO DE COMANDOS DE USUÁRIO PARA ALTERAÇÃO DA PÁGINA DE MEMÓRIA
#DEFINE	BANK0	BCF STATUS,RP0	;SETA BANK 0 DE MEMÓRIA
#DEFINE	BANK1	BSF STATUS,RP0	;SETA BANK 1 DE MAMÓRIA

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         VARIÁVEIS                               *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DOS NOMES E ENDEREÇOS DE TODAS AS VARIÁVEIS UTILIZADAS 
; PELO SISTEMA

	CBLOCK	0x20	;ENDEREÇO INICIAL DA MEMÓRIA DE
					;USUÁRIO
		W_TEMP		;REGISTRADORES TEMPORÁRIOS PARA USO
		STATUS_TEMP	;JUNTO ÀS INTERRUPÇÕES

		; VARIÁVEL 'VALOR_TIMER' É USADA PARA SALVAR O VALOR DE TMR0 PARA QUANDO A
		; PORTA GP4 MUDA DE ESTADO (TRANSIÇÃO LOW-HIGH), O QUE É CONSIDERADO COMO
		; 'FIM DA CONTAGEM' PARA O PROGRAMA
	
		VALOR_TIMER
		
		;COLOQUE AQUI SUAS NOVAS VARIÁVEIS
		;NÃO ESQUEÇA COMENTÁRIOS ESCLARECEDORES

	ENDC			;FIM DO BLOCO DE DEFINIÇÃO DE VARIÁVEIS

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                        FLAGS INTERNOS                           *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS FLAGS UTILIZADOS PELO SISTEMA

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         CONSTANTES                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODAS AS CONSTANTES UTILIZADAS PELO SISTEMA

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           ENTRADAS                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO ENTRADA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           SAÍDAS                                *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO SAÍDA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       VETOR DE RESET                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	ORG	0x00			;ENDEREÇO INICIAL DE PROCESSAMENTO
	GOTO	INICIO
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    INÍCIO DA INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; ENDEREÇO DE DESVIO DAS INTERRUPÇÕES. A PRIMEIRA TAREFA É SALVAR OS
; VALORES DE "W" E "STATUS" PARA RECUPERAÇÃO FUTURA

	ORG	0x04			;ENDEREÇO INICIAL DA INTERRUPÇÃO
	MOVWF	W_TEMP		;COPIA W PARA W_TEMP
	SWAPF	STATUS,W
	MOVWF	STATUS_TEMP	;COPIA STATUS PARA STATUS_TEMP
	
	; TRATAMENTO DAS INTERRUPÇÕES QUE OCORREM:
	; INTERRUPÇÃO PARA QUANDO GP4 MUDA DE ESTADO HIGH-LOW: COMEÇO DA CONTAGEM
	; INTERRUPÇÃO PARA QUANDO GP4 MUDA DE ESTADO LOW-HIGH: FIM DA CONTAGEM
	
	; HOUVE INTERRUPÇÃO, OU SEJA, OCORREU UMA MUDANÇA DE ESTADO NA PORTA GP4 E
	; O FLUXO DE EXECUÇÃO PASSA PARA O TRATAMENTO DE INTERRUPÇÃO (AQUI)
	
	; VERIFICAMOS VALOR DE GP4 
	; (GP4 = 0 - TRANSIÇÃO HIGH-LOW E COMEÇA A CONTAGEM DE TMR0)
	; (GP4 = 1 - TRANSIÇÃO LOW-HIGH E TERMINA A CONTAGEM DE TMR0)
	BTFSS	GPIO, GP4
	; GP4 = 0: EXECUTA PRIMEIRA INSTRUÇÃO
	GOTO	INTER_GP4_HIGH
	; GP4 = 1: EXECUTA SEGUNDA INSTRUÇÃO
	; PARA GP4 COM VALOR EM 1, SIGNIFICA QUE A CONTAGEM DE TMR0 CHEGA AO FIM
	
	MOVFW	TMR0
	MOVWF	VALOR_TIMER ; SALVAMOS O VALOR DO FIM DE TMR0 NA VARIÁVEL 'VALOR_TIMER'
	
	; VERIFICAMOS VALOR DE 'VALOR_TIMER' A PARTIR DE SUBTRAÇÕES PARA DESCOBRIR
	; SE 'VALOR_TIMER' É MENOR OU MAIOR QUE OS TEMPOS DE DURAÇÃO PERMITIDOS
	
	; AQUI, COMPARAMOS 'VALOR_TIMER' COM O VALOR DE 85 us; 
	; SE 'VALOR_TIMER' É MAIOR: DURAÇÃO DO PULSO É MAIOR QUE 170 (POIS 85 * 2 = 170, ESTAMOS USANDO PRESCALER 1:2)
	MOVLW	.85
	SUBWF	VALOR_TIMER, 0	; SUBTRAI WREG DE VALOR_TIMER: VALOR_TIMER - 85 (RESULTADO SALVO EM WREG)
	; VERIFICA VALOR DE CARRY NO REGISTRADOR STATUS (CARRY = 1 SE RESULTADO DE SUBT É POSITIVO; CARRY = 0 SE RESULTADO DE SUBT É NEGATIVO)
	BTFSS	STATUS, C
	; C = 0: EXECUTA PRIMEIRA INSTRUÇÃO 
	; (C = 0: RESULTADO É NEGATIVO E VALOR_TIMER É MENOR QUE 85 - ESTÁ FORA DO INTERVALO E RETORNA 'ERRO')
	GOTO	FORA_DE_INTERVALO
	; C = 1: EXECUTA SEGUNDA INSTRUÇÃO
	; (C = 1: RESULTADO É POSITIVO E VALOR_TIMER É MAIOR QUE 85 - PRECISAMOS TESTAR PARA OUTROS VALORES DE TEMPO)
	
	; VERIFICAMOS SE Z - STATUS É IGUAL A 0 OU A 1
	; SE Z = 1, O RESULTADO DA SUBTRAÇÃO FOI ZERO E O TEMPO DE DURAÇÃO TAMBÉM ESTÁ FORA DO INTERVALO
	; EXEMPLO: TEMPO DE DURAÇÃO 170, TMR0 EM 85; QUANDO FAZEMOS 85 - 85 = 0; SABEMOS QUE 170 ESTÁ FORA DO INTERVALO
	; APENAS VALORES MAIORES QUE 170 (E MENORES QUE 230, NO CASO DO PRIMEIRO INTERVALO) SÃO ACEITOS
	BTFSC	STATUS, Z
	; Z = 1: EXECUTA PRIMEIRA INSTRUÇÃO
	GOTO	FORA_DE_INTERVALO
	; Z = 0: EXECUTA SEGUNDA INSTRUÇÃO (NO CASO, SEGUE COM AS VERIFICAÇÕES SEGUINTES)
	
	; AQUI, COMPARAMOS 'VALOR_TIMER' COM O VALOR DE 115 us; 
	MOVLW	.115
	SUBWF	VALOR_TIMER, 0	; SUBTRAI WREG DE VALOR_TIMER: VALOR_TIMER - 115 (RESULTADO SALVO EM WREG)
	; VERIFICA VALOR DE CARRY NO REGISTRADOR STATUS (CARRY = 1 SE RESULTADO DE SUBT É POSITIVO; CARRY = 0 SE RESULTADO DE SUBT É NEGATIVO)
	BTFSS	STATUS, C
	
	; C = 0: EXECUTA PRIMEIRA INSTRUÇÃO 
	; (C = 0: RESULTADO É NEGATIVO E VALOR_TIMER É MENOR QUE 155 - ASSIM O TEMPO DE DURAÇÃO ESTÁ DENTRO DO
	; INTERVALO DE ]85, 115[ E RETORNAMOS NA SAÍDA O TIPO LOW - GP2 = 0, GP1 = 0, GP0 = 1)
	GOTO	INTERVALO_LOW
	; C = 1: EXECUTA SEGUNDA INSTRUÇÃO
	; (C = 1: RESULTADO É POSITIVO E VALOR_TIMER É MAIOR QUE 115 - PRECISAMOS TESTAR PARA OUTROS VALORES DE TEMPO)
	
	; VERIFICAMOS SE Z - STATUS É IGUAL A 0 OU A 1
	BTFSC	STATUS, Z
	; Z = 1: EXECUTA PRIMEIRA INSTRUÇÃO
	GOTO	FORA_DE_INTERVALO
	; Z = 0: EXECUTA SEGUNDA INSTRUÇÃO (VALOR DE TMR0 DENTRO DO INTERVALO)
	
	; AQUI, COMPARAMOS 'VALOR_TIMER' COM O VALOR DE 175 us; 
	MOVLW	.175
	SUBWF	VALOR_TIMER, 0	; SUBTRAI WREG DE VALOR_TIMER: VALOR_TIMER - 175 (RESULTADO SALVO EM WREG)
	; VERIFICA VALOR DE CARRY NO REGISTRADOR STATUS (CARRY = 1 SE RESULTADO DE SUBT É POSITIVO; CARRY = 0 SE RESULTADO DE SUBT É NEGATIVO)
	BTFSS	STATUS, C
	; C = 0: EXECUTA PRIMEIRA INSTRUÇÃO 
	; (C = 0: RESULTADO É NEGATIVO E VALOR_TIMER É MENOR QUE 175 - ASSIM O TEMPO DE DURAÇÃO É MAIOR QUE 115, MAS MENOR QUE 175
	; ESTÁ FORA DO INTERVALO E RETORNA 'ERRO'
	GOTO	FORA_DE_INTERVALO
	; C = 1: EXECUTA SEGUNDA INSTRUÇÃO
	; (C = 1: RESULTADO É POSITIVO E VALOR_TIMER É MAIOR QUE 175 - PRECISAMOS TESTAR PARA OUTROS VALORES DE TEMPO)
	
	; VERIFICAMOS SE Z - STATUS É IGUAL A 0 OU A 1
	BTFSC	STATUS, Z
	; Z = 1: EXECUTA PRIMEIRA INSTRUÇÃO
	GOTO	FORA_DE_INTERVALO
	; Z = 0: EXECUTA SEGUNDA INSTRUÇÃO (NO CASO, SEGUE COM AS VERIFICAÇÕES SEGUINTES)
	
	; AQUI, COMPARAMOS 'VALOR_TIMER' COM O VALOR DE 225 us; 
	MOVLW	.225
	SUBWF	VALOR_TIMER, 0	; SUBTRAI WREG DE VALOR_TIMER: VALOR_TIMER - 225 (RESULTADO SALVO EM WREG)
	; VERIFICA VALOR DE CARRY NO REGISTRADOR STATUS (CARRY = 1 SE RESULTADO DE SUBT É POSITIVO; CARRY = 0 SE RESULTADO DE SUBT É NEGATIVO)
	BTFSS	STATUS, C
	; C = 0: EXECUTA PRIMEIRA INSTRUÇÃO 
	; (C = 0: RESULTADO É NEGATIVO E VALOR_TIMER É MENOR QUE 225 - ASSIM O TEMPO DE DURAÇÃO ESTÁ DENTRO DO INTERVALO ]175, 225[
	; INTERVALO DE ]175, 225[ E RETORNAMOS NA SAÍDA O TIPO HIGH - GP2 = 0, GP1 = 1, GP0 = 0)
	
	; VERIFICAMOS SE Z - STATUS É IGUAL A 0 OU A 1
	BTFSC	STATUS, Z
	; Z = 1: EXECUTA PRIMEIRA INSTRUÇÃO
	GOTO	FORA_DE_INTERVALO
	; Z = 0: EXECUTA SEGUNDA INSTRUÇÃO (VALOR DE TMR0 DENTRO DO INTERVALO)
	
	GOTO	INTERVALO_HIGH
	; C = 1: EXECUTA SEGUNDA INSTRUÇÃO 
	; (C = 1: RESULTADO É POSITIVO E VALOR_TIMER É MAIOR QUE 225 - ASSIM O TEMPO DE DURAÇÃO ESTÁ FORA DO INTERVALO ]175, 225[ E TEMOS ERRO
	GOTO	FORA_DE_INTERVALO
	
INTER_GP4_HIGH ; LABEL - EXECUÇÃO QUANDO GP1 = 0
	; COMEÇAMOS A CONTAGEM DE TMR0
	
	; GARANTIMOS QUE FLAG DE ESTOURO TEM VALOR 0
	BCF	INTCON, T0IF
	; TMR0 RECEBE VALOR DE OFFSET 5 PARA COMEÇAR A CONTAGEM
	; OFFSET EM 4 GARANTE O ADEQUADO FUNCIONAMENTO DO PROGRAMA
	MOVLW	.4
	MOVWF	TMR0
	; GARANTIMOS QUE GPIF (FLAG PARA MUDANÇA DE ESTADO DE PORTA, NESSE CASO, DE GP4) É 0
	BCF	INTCON, GPIF
	
	GOTO	SAI_INT ; SAÍDA DO TRATAMENTO DE INTERRUPÇÃO
	
INTERVALO_HIGH ; LABEL - TEMPO DE DURAÇÃO NO INTERVALO DE ]85, 115[
	
	; VERIFICAMOS SE Z - STATUS É IGUAL A 0 OU A 1
	;BTFSC	STATUS, Z
	; Z = 1: EXECUTA PRIMEIRA INSTRUÇÃO
	;GOTO	FORA_DE_INTERVALO
	; Z = 0: EXECUTA SEGUNDA INSTRUÇÃO (VALOR DE TMR0 DENTRO DO INTERVALO)
	
	; PARA RESULTADO DO TEMPO DE DURAÇÃO NO INTEVALO ]85, 115[, SAÍDA DO TIPO HIGH
	; LOW - GP2 = 0, GP1 = 1, GP0 = 0
	BCF	GPIO, GP2
	BSF	GPIO, GP1
	BCF	GPIO, GP0
	
	; GARANTIMOS QUE GPIF (FLAG PARA MUDANÇA DE ESTADO DE PORTA, NESSE CASO, DE GP4) É 0
	BCF	INTCON, GPIF
	
	GOTO	SAI_INT
	
INTERVALO_LOW ; LABEL - TEMPO DE DURAÇÃO NO INTERVALO DE ]85, 115[
	
	; VERIFICAMOS SE Z - STATUS É IGUAL A 0 OU A 1
	;BTFSC	STATUS, Z
	; Z = 1: EXECUTA PRIMEIRA INSTRUÇÃO
	;GOTO	FORA_DE_INTERVALO
	; Z = 0: EXECUTA SEGUNDA INSTRUÇÃO (VALOR DE TMR0 DENTRO DO INTERVALO)
	
	; PARA RESULTADO DO TEMPO DE DURAÇÃO NO INTEVALO ]85, 115[, SAÍDA DO TIPO LOW
	; LOW - GP2 = 0, GP1 = 0, GP0 = 1
	BCF	GPIO, GP2
	BCF	GPIO, GP1
	BSF	GPIO, GP0
	
	; GARANTIMOS QUE GPIF (FLAG PARA MUDANÇA DE ESTADO DE PORTA, NESSE CASO, DE GP4) É 0
	BCF	INTCON, GPIF
	
	GOTO	SAI_INT
	
FORA_DE_INTERVALO ; LABEL - QUANDO TEMPO DE DURAÇÃO ESTÁ FORA DE INTERVALO
	; PARA RESULTADO DO TEMPO DE DURAÇÃO FORA DO INTEVALO, SAÍDA EM ERRO
	; ERRO - GP2 = 1, GP1 = 0, GP0 = 0
	BSF	GPIO, GP2
	BCF	GPIO, GP1
	BCF	GPIO, GP0
	
	; GARANTIMOS QUE GPIF (FLAG PARA MUDANÇA DE ESTADO DE PORTA, NESSE CASO, DE GP4) É 0
	BCF	INTCON, GPIF
	
	GOTO	SAI_INT

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    ROTINA DE INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; AQUI SERÃO ESCRITAS AS ROTINAS DE RECONHECIMENTO E TRATAMENTO DAS
; INTERRUPÇÕES

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                 ROTINA DE SAÍDA DA INTERRUPÇÃO                  *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; OS VALORES DE "W" E "STATUS" DEVEM SER RECUPERADOS ANTES DE 
; RETORNAR DA INTERRUPÇÃO

SAI_INT
	SWAPF	STATUS_TEMP,W
	MOVWF	STATUS		;MOVE STATUS_TEMP PARA STATUS
	SWAPF	W_TEMP,F
	SWAPF	W_TEMP,W	;MOVE W_TEMP PARA W
	RETFIE

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*	            	 ROTINAS E SUBROTINAS                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; CADA ROTINA OU SUBROTINA DEVE POSSUIR A DESCRIÇÃO DE FUNCIONAMENTO
; E UM NOME COERENTE ÀS SUAS FUNÇÕES.

SUBROTINA1

	;CORPO DA ROTINA

	RETURN

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIO DO PROGRAMA                          *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	
INICIO
	BANK1			;ALTERA PARA O BANCO 1
	
	; ENTRADA: GP4
	; SAÍDA: GP2, GP1, GP0
	
	MOVLW	B'00010000' 	;CONFIGURA TODAS AS PORTAS DO GPIO (PINOS)
	MOVWF	TRISIO		;COMO SAÍDAS
	CLRF	ANSEL 		;DEFINE PORTAS COMO Digital I/O
	
	; DESABILITA PULL-UP NAS PORTAS

	MOVLW	B'10000000'
	MOVWF	OPTION_REG	;DEFINE OPÇÕES DE OPERAÇÃO
	
	; HABILITA INTERRUPÇÕES GLOBAIS; HABILITA INTERRUPÇÃO NA MUDANÇA DE ESTADO DE PORTA
	
	MOVLW	B'10001000'
	MOVWF	INTCON		;DEFINE OPÇÕES DE INTERRUPÇÕES
	
	; HABILITA USO DA PORTA GP4 PARA INTERRUPÇÕES QUANDO O ESTADO DESSA PORTA MUDAR
	
	MOVLW	B'00010000'
	MOVWF	IOC
	
	BANK0			;RETORNA PARA O BANCO 0
	MOVLW	B'00000111'
	MOVWF	CMCON		;DEFINE O MODO DE OPERAÇÃO DO COMPARADOR ANALÓGICO

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIALIZAÇÃO DAS VARIÁVEIS                 *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	; VARIÁVEL 'VALOR_TIMER' NÃO PRECISA SER INICIALIZADA, POIS IRÁ RECEBER
	; O VALOR DE TMR0 QUANDO ACABAR A SUA CONTAGEM (NA TRANSIÇÃO LOW-HIGH DE GP4)
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ROTINA PRINCIPAL                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
MAIN
	; FUNCIONAMENTO
	; UM SINAL DE ENTRADA É APLICADO EM GP4; A PARTIR DO TEMPO DE DURAÇÃO DO SINAL
	; QUANDO ELE ESTÁ EM NÍVEL BAIXO, A SAÍDA É DEFINIDA COMO TIPO LOW, HIGH OU ERRO COM
	; O USO DAS PORTAS DE SAÍDA GP2, GP1, GP0;
	
	; PARA CONTAR O TEMPO DE DURAÇÃO DO SINAL (EM NÍVEL BAIXO), O TMR0 SERÁ UTILIZADO;
	; HÁ UMA INTERRUPÇÃO A CADA MUDANÇA DE ESTADO DE GP4; QUANDO GP4 MUDA DE HIGH PARA LOW,
	; O CONTADOR TMR0 COMEÇA A SUA CONTAGEM (USO DE PRESCALER 1:2); QUANDO GP4 MUDA DE LOW
	; PARA HIGH, A CONTAGEM DE TMR0 É SALVA EM UMA VARIÁVEL E ANALISADO; PARA VALORES DE DURAÇÃO
	; DE TEMPO ACEITOS, O PROGRAMA RETORNA A SAÍDA PARA GP2, GP1 E GP0 CORRESPONDENTE; CASO
	; A DURAÇÃO ESTEJA FORA DOS INTERVALOS ACEITOS, UM VALOR QUE CORRESPONDE A ERRO NAS PORTAS
	; DE SAÍDA GP2, GP1 E GP0 É A SAÍDA DO PROGRAMA
	
	; INTERVALOS: ]170, 230[, ]350, 450[
	
	; OU SEJA:    [171, 229], [351, 449]
	; POR QUESTÕES DE PRECISÃO DO PRÓPRIO MICROCONTROLADOR (LIMITAÇÃO DELE), PARA A PRESENTE IMPLEMENTAÇÃO,
	; OS VALORES DE TEMPO DE 229 us E 449 us SÃO CONSIDERADOS FORA DO INTERVALO ACEITO!
	
	; LÓGICA DO PROGRAMA NO TRATAMENTO DAS INTERRUPÇÕES; MAIN VAZIA

	GOTO	MAIN

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       FIM DO PROGRAMA                           *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	END
